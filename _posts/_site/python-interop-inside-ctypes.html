<p>Last time we’ve looked at using ctypes to call C API, and writing extension module using Python/C API. Now we can finally tie these two together - looking at how ctypes is actually implemented using mix of Python/C API  and Python code.</p>

<ul>
  <li>You can find CPython source code <a href="https://github.com/python/cpython">here</a>.</li>
  <li>ctypes’ C implementation is <a href="https://github.com/python/cpython/tree/master/Modules/_ctypes">here</a></li>
  <li>ctypes’ python implementation is <a href="https://github.com/python/cpython/tree/master/Lib/ctypes">here</a>.</li>
</ul>

<!--more-->

<h2 id="loading-libraries">Loading libraries</h2>

<p>Recall that in <code class="highlighter-rouge">ctypes</code> we have <code class="highlighter-rouge">cdll</code>, <code class="highlighter-rouge">windll</code>, <code class="highlighter-rouge">oledll</code> object to help loading libraries. They are really LibraryLoader objects:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">cdll</span>
<span class="o">&lt;</span><span class="n">ctypes</span><span class="o">.</span><span class="n">LibraryLoader</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x000000000592F470</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>And that type is just plain python code:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LibraryLoader</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dlltype</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dlltype</span> <span class="o">=</span> <span class="n">dlltype</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">'_'</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">AttributeError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">dll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dlltype</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dll</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dll</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LoadLibrary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dlltype</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">__getattr__</code> is the magic that implements attribute-based library loading. Note that if the attribute is already there, CPython returns that attribute immediately without calling <code class="highlighter-rouge">__getattr__</code>. Otherwise you would end up with multiple copies of the same attribute, or keeping creating new library objects and discarding old ones - not very efficent.</p>

<p><code class="highlighter-rouge">dlltype</code> is the type for each kind of DLL, such as <code class="highlighter-rouge">CDLL</code>, <code class="highlighter-rouge">PyDll</code>, <code class="highlighter-rouge">WinDll</code>, <code class="highlighter-rouge">OleDll</code>. <code class="highlighter-rouge">__getattr__</code> creates new instances of these types as needed.</p>

<p><code class="highlighter-rouge">cdll</code>, <code class="highlighter-rouge">pydll</code>, <code class="highlighter-rouge">windll</code>, <code class="highlighter-rouge">oledll</code> are simply instances of <code class="highlighter-rouge">LibraryLoader</code> class, which are created with corresponding dlltype.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cdll</span> <span class="o">=</span> <span class="n">LibraryLoader</span><span class="p">(</span><span class="n">CDLL</span><span class="p">)</span>
<span class="n">pydll</span> <span class="o">=</span> <span class="n">LibraryLoader</span><span class="p">(</span><span class="n">PyDLL</span><span class="p">)</span>

<span class="k">if</span> <span class="n">_os</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">"nt"</span><span class="p">:</span>
    <span class="n">pythonapi</span> <span class="o">=</span> <span class="n">PyDLL</span><span class="p">(</span><span class="s">"python dll"</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">_sys</span><span class="o">.</span><span class="n">dllhandle</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">_sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s">"cygwin"</span><span class="p">:</span>
    <span class="n">pythonapi</span> <span class="o">=</span> <span class="n">PyDLL</span><span class="p">(</span><span class="s">"libpython</span><span class="si">%</span><span class="s">d.</span><span class="si">%</span><span class="s">d.dll"</span> <span class="o">%</span> <span class="n">_sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">pythonapi</span> <span class="o">=</span> <span class="n">PyDLL</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

<span class="k">if</span> <span class="n">_os</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">"nt"</span><span class="p">:</span>
    <span class="n">windll</span> <span class="o">=</span> <span class="n">LibraryLoader</span><span class="p">(</span><span class="n">WinDLL</span><span class="p">)</span>
    <span class="n">oledll</span> <span class="o">=</span> <span class="n">LibraryLoader</span><span class="p">(</span><span class="n">OleDLL</span><span class="p">)</span>
</code></pre></div></div>

<p>Let’s look at <code class="highlighter-rouge">CDLL</code> first - its init does a <code class="highlighter-rouge">dlopen</code> to load the library:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CDLL</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">DEFAULT_MODE</span><span class="p">,</span> <span class="n">handle</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
        <span class="k">if</span> <span class="n">handle</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span> <span class="o">=</span> <span class="n">_dlopen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span> <span class="o">=</span> <span class="n">handle</span>
</code></pre></div></div>

<p>The attribute access are defined in <code class="highlighter-rouge">__getattr__</code> as well - it gets translated to <code class="highlighter-rouge">__getitem__</code> call which creates a new <code class="highlighter-rouge">_FuncPtr</code> instance.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">'__'</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">'__'</span><span class="p">):</span>
            <span class="k">raise</span> <span class="nb">AttributeError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_ordinal</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FuncPtr</span><span class="p">((</span><span class="n">name_or_ordinal</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_ordinal</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">func</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">name_or_ordinal</span>
        <span class="k">return</span> <span class="n">func</span>
</code></pre></div></div>

<p>We’ll look at <code class="highlighter-rouge">_FuncPtr</code> later - for now it’s good enough to know it represents function pointer.</p>

<p>The difference between OleDll and WinDll is simply the default settings:</p>

<p>For <code class="highlighter-rouge">CDLL</code> - the base class:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CDLL</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">_func_flags_</span> <span class="o">=</span> <span class="n">_FUNCFLAG_CDECL</span>
    <span class="n">_func_restype_</span> <span class="o">=</span> <span class="n">c_int</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">WinDll</code> has <code class="highlighter-rouge">StdCall</code> as default calling convention, and deriving from <code class="highlighter-rouge">CDLL</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">class</span> <span class="nc">WinDLL</span><span class="p">(</span><span class="n">CDLL</span><span class="p">):</span>
        <span class="n">_func_flags_</span> <span class="o">=</span> <span class="n">_FUNCFLAG_STDCALL</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">OleDll</code> is like <code class="highlighter-rouge">WinDll</code> (in terms of calling convention), but the default return type is <code class="highlighter-rouge">HRESULT</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">class</span> <span class="nc">OleDLL</span><span class="p">(</span><span class="n">CDLL</span><span class="p">):</span>
        <span class="n">_func_flags_</span> <span class="o">=</span> <span class="n">_FUNCFLAG_STDCALL</span>
        <span class="n">_func_restype_</span> <span class="o">=</span> <span class="n">HRESULT</span>
</code></pre></div></div>

<h2 id="calling-the-function">Calling the function</h2>

<p>In last section we discussed the how library are loaded and we didn’t talk about functions yet. 
Functions are presented as <code class="highlighter-rouge">_FuncPtr</code> which is basically a <code class="highlighter-rouge">_CFuncPtr</code> in _ctypes module:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">class</span> <span class="nc">_FuncPtr</span><span class="p">(</span><span class="n">_CFuncPtr</span><span class="p">):</span>
            <span class="n">_flags_</span> <span class="o">=</span> <span class="n">flags</span>
            <span class="n">_restype_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func_restype_</span>
</code></pre></div></div>

<p>Now it’s type to put our Python/C API knowledge to good use - <code class="highlighter-rouge">_CFuncPtr</code> is implemented in C:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PyTypeObject</span> <span class="n">PyCFuncPtr_Type</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">"_ctypes.PyCFuncPtr"</span><span class="p">,</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">PyCFuncPtrObject</span><span class="p">),</span>                           <span class="cm">/* tp_basicsize */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_itemsize */</span>
    <span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">PyCFuncPtr_dealloc</span><span class="p">,</span>             <span class="cm">/* tp_dealloc */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_print */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_getattr */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_setattr */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_reserved */</span>
    <span class="p">(</span><span class="n">reprfunc</span><span class="p">)</span><span class="n">PyCFuncPtr_repr</span><span class="p">,</span>                  <span class="cm">/* tp_repr */</span>
    <span class="o">&amp;</span><span class="n">PyCFuncPtr_as_number</span><span class="p">,</span>                      <span class="cm">/* tp_as_number */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_as_sequence */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_as_mapping */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_hash */</span>
    <span class="p">(</span><span class="n">ternaryfunc</span><span class="p">)</span><span class="n">PyCFuncPtr_call</span><span class="p">,</span>               <span class="cm">/* tp_call */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_str */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_getattro */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_setattro */</span>
    <span class="o">&amp;</span><span class="n">PyCData_as_buffer</span><span class="p">,</span>                         <span class="cm">/* tp_as_buffer */</span>
    <span class="n">Py_TPFLAGS_DEFAULT</span> <span class="o">|</span> <span class="n">Py_TPFLAGS_BASETYPE</span><span class="p">,</span> <span class="cm">/* tp_flags */</span>
    <span class="s">"Function Pointer"</span><span class="p">,</span>                         <span class="cm">/* tp_doc */</span>
    <span class="p">(</span><span class="n">traverseproc</span><span class="p">)</span><span class="n">PyCFuncPtr_traverse</span><span class="p">,</span>          <span class="cm">/* tp_traverse */</span>
    <span class="p">(</span><span class="n">inquiry</span><span class="p">)</span><span class="n">PyCFuncPtr_clear</span><span class="p">,</span>                  <span class="cm">/* tp_clear */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_richcompare */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_weaklistoffset */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_iter */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_iternext */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_methods */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_members */</span>
    <span class="n">PyCFuncPtr_getsets</span><span class="p">,</span>                         <span class="cm">/* tp_getset */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_base */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_dict */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_descr_get */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_descr_set */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_dictoffset */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_init */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_alloc */</span>
    <span class="n">PyCFuncPtr_new</span><span class="p">,</span>                             <span class="cm">/* tp_new */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_free */</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let’s look at the <code class="highlighter-rouge">tp_new</code> function <code class="highlighter-rouge">PyCFuncPtr_new</code> first:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PyCFuncPtr_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...
</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">PyTuple_GET_SIZE</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">PyTuple_Check</span><span class="p">(</span><span class="n">PyTuple_GET_ITEM</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">PyCFuncPtr_FromDll</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">);</span>
</code></pre></div></div>

<p>PyCFuncPtr_FromDll has quite a bit of code, but in the end these two lines are the most important:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">PyCFuncPtr_FromDll</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...
</span>
<span class="cp">#ifdef MS_WIN32
</span>    <span class="n">address</span> <span class="o">=</span> <span class="n">FindAddress</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">type</span><span class="p">);</span>
    <span class="c1">// ...
</span><span class="cp">#else
</span>    <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="n">PPROC</span><span class="p">)</span><span class="n">ctypes_dlsym</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="c1">// ...
</span></code></pre></div></div>

<p>In Windows it does a <code class="highlighter-rouge">GetProcAddress</code> and in linux/mac it does <code class="highlighter-rouge">dlsym</code>.</p>

<p>As far as calling function goes, calling the <code class="highlighter-rouge">_CFuncPtr</code> effectively calls <code class="highlighter-rouge">tp_call</code> field which is <code class="highlighter-rouge">PyCFuncPtr_call</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">PyCFuncPtr_call</span><span class="p">(</span><span class="n">PyCFuncPtrObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">inargs</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...
</span>    <span class="n">callargs</span> <span class="o">=</span> <span class="n">_build_callargs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">argtypes</span><span class="p">,</span>
                               <span class="n">inargs</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span>
                               <span class="o">&amp;</span><span class="n">outmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inoutmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">numretvals</span><span class="p">);</span> 
    <span class="c1">// ...
</span>    <span class="n">result</span> <span class="o">=</span> <span class="n">_ctypes_callproc</span><span class="p">(</span><span class="n">pProc</span><span class="p">,</span>
                       <span class="n">callargs</span><span class="p">,</span>
<span class="cp">#ifdef MS_WIN32
</span>                       <span class="n">piunk</span><span class="p">,</span>
                       <span class="n">self</span><span class="o">-&gt;</span><span class="n">iid</span><span class="p">,</span>
<span class="cp">#endif
</span>                       <span class="n">dict</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
                       <span class="n">converters</span><span class="p">,</span>
                       <span class="n">restype</span><span class="p">,</span>
                       <span class="n">checker</span><span class="p">);</span>
    <span class="c1">// ...
</span>    <span class="k">return</span> <span class="n">_build_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">callargs</span><span class="p">,</span>
                         <span class="n">outmask</span><span class="p">,</span> <span class="n">inoutmask</span><span class="p">,</span> <span class="n">numretvals</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>There are a lot of code in the function above, but it basically does 3 steps - preparing the arguments, making the call, and building the result and propagating the arguments back (for out/inout parameters).</p>

<p>Eventually it uses ffi_call from <a href="https://sourceware.org/libffi/">FFI</a> to make the call.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span><span class="n">FFI_OK</span> <span class="o">!=</span> <span class="n">ffi_prep_cif</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cif</span><span class="p">,</span>
                               <span class="n">cc</span><span class="p">,</span>
                               <span class="n">argcount</span><span class="p">,</span>
                               <span class="n">restype</span><span class="p">,</span>
                               <span class="n">atypes</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_RuntimeError</span><span class="p">,</span>
                        <span class="s">"ffi_prep_cif failed"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>


    <span class="n">ffi_call</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cif</span><span class="p">,</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pProc</span><span class="p">,</span> <span class="n">resmem</span><span class="p">,</span> <span class="n">avalues</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">FFI</code> itself is quite complicated as it needs to understand all calling conventions and for different CPUs as well (for example, procedure calls in amd64 is drastically different in SPARC) - for now just think of it as a way of being able to say “I want to make a CDecl call to this function using these arguments”, without worrying about all the details in the ABI (Application Binary Interface) level.</p>

<h2 id="structs-and-metaclasses">Structs and metaclasses</h2>

<p>Now that we’ve looked at library loading and function loading/calling, let’s take a look at how structure is implemented. Recall how you write a structure:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">VECTOR3</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s">"x"</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s">"y"</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s">"z"</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)]</span>
</code></pre></div></div>

<p>Somehow the VECTOR3 class gets the magic x, y, z attributes. How does this work?</p>

<p>The magic is in the <code class="highlighter-rouge">PyCStructType</code> metaclass.</p>

<blockquote>
  <p>Metaclass is a type used to create other types - it is an alternative way of doing subclassing / inheritance in Python, and a very powerful one too. If you understand metaclass you understand Python’s type system. If you are curious, see <a href="https://jakevdp.github.io/blog/2012/12/01/a-primer-on-python-metaclasses/">Primer on metaclasses</a> on a excellent explanation on metaclasses and <a href="https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/">Understanding Python Metaclasses</a> for a deeper dive. There is also a <a href="https://blog.ionelmc.ro/presentations/metaclase/">presentation version</a> as well.</p>
</blockquote>

<p><code class="highlighter-rouge">ctypes.Structure</code> is implemented in <code class="highlighter-rouge">_ctypes</code> module as <code class="highlighter-rouge">Struct_Type</code>, and type of <code class="highlighter-rouge">Struct_Type</code> is <code class="highlighter-rouge">PyCStructType</code> (<code class="highlighter-rouge">PyCStructType_Type</code> object).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">Py_TYPE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Struct_Type</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">PyCStructType_Type</span><span class="p">;</span>
    <span class="n">Struct_Type</span><span class="p">.</span><span class="n">tp_base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">PyCData_Type</span><span class="p">;</span>
</code></pre></div></div>

<p>This makes PyCStructType` a <em>metaclass</em>.</p>

<p>Whenever you are deriving from <code class="highlighter-rouge">ctypes.Strucuture</code> like following:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">VECTOR3</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s">"x"</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s">"y"</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s">"z"</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)]</span>
</code></pre></div></div>

<p>This effectively becomes:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VECTOR3</span> <span class="o">=</span> <span class="n">PyCStructType</span><span class="p">(</span><span class="s">'VECTOR3'</span><span class="p">,</span> <span class="p">(</span><span class="n">Structure</span><span class="p">),</span> <span class="p">{</span> <span class="s">'fields'</span> <span class="p">:</span> <span class="p">[(</span><span class="s">"x"</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s">"y"</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s">"z"</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)]</span>
<span class="p">})</span>
</code></pre></div></div>

<p>Note that <code class="highlighter-rouge">tp_new</code> of <code class="highlighter-rouge">PyCStructType_Type</code> is PyCStructType_new:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PyTypeObject</span> <span class="n">PyCStructType_Type</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">"_ctypes.PyCStructType"</span><span class="p">,</span>                            <span class="cm">/* tp_name */</span>
    <span class="n">PyCStructType_setattro</span><span class="p">,</span>                     <span class="cm">/* tp_setattro */</span>
    <span class="n">CDataType_methods</span><span class="p">,</span>                          <span class="cm">/* tp_methods */</span>
    <span class="n">PyCStructType_new</span><span class="p">,</span>                                  <span class="cm">/* tp_new */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>So this ends up calling PyCStructType_new with those arguments, which retrieves the <code class="highlighter-rouge">_fields_</code> from supplied dictionary, and assign it to <code class="highlighter-rouge">_fields_</code> attribute, triggering <code class="highlighter-rouge">PyCStructType_setattro</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">PyCStructType_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">StructUnionType_new</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">StructUnionType_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">isStruct</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">fields</span><span class="p">;</span>
    <span class="n">StgDictObject</span> <span class="o">*</span><span class="n">dict</span><span class="p">;</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="p">)</span><span class="n">PyType_Type</span><span class="p">.</span><span class="n">tp_new</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">);</span>
    <span class="c1">//...
</span>    <span class="n">PyDict_Update</span><span class="p">((</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">dict</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">tp_dict</span><span class="p">));</span>
    <span class="c1">//...
</span>    <span class="n">fields</span> <span class="o">=</span> <span class="n">PyDict_GetItemString</span><span class="p">((</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">dict</span><span class="p">,</span> <span class="s">"_fields_"</span><span class="p">);</span>
    <span class="c1">//...
</span>    <span class="n">fields</span> <span class="o">=</span> <span class="n">PyDict_GetItemString</span><span class="p">((</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">dict</span><span class="p">,</span> <span class="s">"_fields_"</span><span class="p">);</span>
    <span class="c1">//...
</span>    <span class="n">PyObject_SetAttrString</span><span class="p">((</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">result</span><span class="p">,</span> <span class="s">"_fields_"</span><span class="p">,</span> <span class="n">fields</span><span class="p">));</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">tp_setattro</code> catch the <code class="highlighter-rouge">_field_</code> access (from <code class="highlighter-rouge">PyObject_SetAttrString</code> call) and update the internal dictionary on the newly created <code class="highlighter-rouge">VECTOR3</code> type:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span>
<span class="nf">PyCStructType_setattro</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* XXX Should we disallow deleting _fields_? */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">PyType_Type</span><span class="p">.</span><span class="n">tp_setattro</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="n">PyUnicode_Check</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="n">_PyUnicode_EqualToASCIIString</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">"_fields_"</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">PyCStructUnionType_update_stgdict</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">PyCStructUnionType_update_stgdict</code> mostly traverse the list of fields and create necessary PyCField instances as corresponding attributes. Interestingly, the attribute assignment also triggers setattro, which simply let it through as it only cares about <code class="highlighter-rouge">_fields_</code> access (otherwise this would be an infinite loop). When you are accessing <code class="highlighter-rouge">myVector3.x</code>, you are setting/getting PyCField instance, which are descriptor classes that binds to the owner class, which is the structure itself.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PyTypeObject</span> <span class="n">PyCField_Type</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">"_ctypes.CField"</span><span class="p">,</span>                                   <span class="cm">/* tp_name */</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">CFieldObject</span><span class="p">),</span>                       <span class="cm">/* tp_basicsize */</span>
    <span class="p">(</span><span class="n">reprfunc</span><span class="p">)</span><span class="n">PyCField_repr</span><span class="p">,</span>                            <span class="cm">/* tp_repr */</span>
    <span class="s">"Structure/Union member"</span><span class="p">,</span>                   <span class="cm">/* tp_doc */</span>
    <span class="p">(</span><span class="n">descrgetfunc</span><span class="p">)</span><span class="n">PyCField_get</span><span class="p">,</span>                 <span class="cm">/* tp_descr_get */</span>
    <span class="p">(</span><span class="n">descrsetfunc</span><span class="p">)</span><span class="n">PyCField_set</span><span class="p">,</span>                 <span class="cm">/* tp_descr_set */</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">PyCField_repr</code> provides the nice output you see here:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">VECTOR3</span><span class="o">.</span><span class="n">x</span>
<span class="o">&lt;</span><span class="n">Field</span> <span class="nb">type</span><span class="o">=</span><span class="n">c_long</span><span class="p">,</span> <span class="n">ofs</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">4</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>While <code class="highlighter-rouge">PyCField_get</code>/<code class="highlighter-rouge">PyCField_set</code> provides access to the field on this structure (<code class="highlighter-rouge">myVector3.x</code>) through descriptor class and bindings to the structure instance:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span>
<span class="nf">PyCField_set</span><span class="p">(</span><span class="n">CFieldObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">inst</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">CDataObject</span> <span class="o">*</span><span class="n">dst</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CDataObject_Check</span><span class="p">(</span><span class="n">inst</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                        <span class="s">"not a ctype instance"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">dst</span> <span class="o">=</span> <span class="p">(</span><span class="n">CDataObject</span> <span class="o">*</span><span class="p">)</span><span class="n">inst</span><span class="p">;</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="n">dst</span><span class="o">-&gt;</span><span class="n">b_ptr</span> <span class="o">+</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                        <span class="s">"can't delete attribute"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">PyCData_set</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">proto</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">setfunc</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span>
                     <span class="n">self</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the above function, <code class="highlighter-rouge">self</code> is the <code class="highlighter-rouge">PyCField</code> instance, <code class="highlighter-rouge">inst</code> is <code class="highlighter-rouge">VECTOR3</code> (or whatever structure you have), and <code class="highlighter-rouge">value</code> is the new value you are assigning with. Eventually it got set on the pointer to the structure + field offset, basically <code class="highlighter-rouge">*(ptr + offset) = value</code>.</p>

<p>But where is that ptr come from?</p>

<p><code class="highlighter-rouge">ctypes.Structure</code> are essentially CDataObject*:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Fields omitted for clarity 
</span><span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">Struct_Type</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">"_ctypes.Structure"</span><span class="p">,</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">CDataObject</span><span class="p">),</span>                        <span class="cm">/* tp_basicsize */</span>
    <span class="n">GenericPyCData_new</span><span class="p">,</span>                         <span class="cm">/* tp_new */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>A <code class="highlighter-rouge">CDataObject</code> looks like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct tagCDataObject {
    PyObject_HEAD
    char *b_ptr;                /* pointer to memory block */
    int  b_needsfree;           /* need _we_ free the memory? */
    CDataObject *b_base;        /* pointer to base object or NULL */
    Py_ssize_t b_size;          /* size of memory block in bytes */
    Py_ssize_t b_length;        /* number of references we need */
    Py_ssize_t b_index;         /* index of this object into base's
                               b_object list */
    PyObject *b_objects;        /* dictionary of references we need to keep, or Py_None */
    union value b_value;
};
</code></pre></div></div>

<p>Just think of it as a generic holder of any value - like VARIANT (if COM is your thing). In particular, <code class="highlighter-rouge">b_value</code> field holds the well known simple data values (it’s a union) and <code class="highlighter-rouge">b_ptr</code> points to the underlying data if it is a more complex type, like structures.</p>

<p>GenericPyCData_new is fairly straight-forward - it allocates enough memory as described by the internal <code class="highlighter-rouge">stgdict</code> dictionary, which you can treat it as physical layout information about its fields and total size, which is calculated when <code class="highlighter-rouge">_fields_</code> get assigned.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">GenericPyCData_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">CDataObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
    <span class="n">StgDictObject</span> <span class="o">*</span><span class="n">dict</span><span class="p">;</span>

    <span class="n">dict</span> <span class="o">=</span> <span class="n">PyType_stgdict</span><span class="p">((</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">type</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dict</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                        <span class="s">"abstract class"</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">dict</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DICTFLAG_FINAL</span><span class="p">;</span>

    <span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="n">CDataObject</span> <span class="o">*</span><span class="p">)</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_alloc</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">b_base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">b_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">b_objects</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">b_length</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">PyCData_MallocBuffer</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dict</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">obj</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>PyCData_MallocBuffer handles two cases - if it is referring to a simple type (like <code class="highlighter-rouge">c_int</code>, etc), there is no need to allocate the int dynamically as it fits perfectly well in the <code class="highlighter-rouge">b_value</code> union field. Otherwise, it allocates the correct buffer size and assign to <code class="highlighter-rouge">b_ptr</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">PyCData_MallocBuffer</span><span class="p">(</span><span class="n">CDataObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">StgDictObject</span> <span class="o">*</span><span class="n">dict</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="kt">size_t</span><span class="p">)</span><span class="n">dict</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">b_value</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* No need to call malloc, can use the default buffer */</span>
        <span class="n">obj</span><span class="o">-&gt;</span><span class="n">b_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">b_value</span><span class="p">;</span>
        <span class="cm">/* The b_needsfree flag does not mean that we actually did
           call PyMem_Malloc to allocate the memory block; instead it
           means we are the *owner* of the memory and are responsible
           for freeing resources associated with the memory.  This is
           also the reason that b_needsfree is exposed to Python.
         */</span>
        <span class="n">obj</span><span class="o">-&gt;</span><span class="n">b_needsfree</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* In python 2.4, and ctypes 0.9.6, the malloc call took about
           33% of the creation time for c_int().
        */</span>
        <span class="n">obj</span><span class="o">-&gt;</span><span class="n">b_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">PyMem_Malloc</span><span class="p">(</span><span class="n">dict</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">b_ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">PyErr_NoMemory</span><span class="p">();</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">obj</span><span class="o">-&gt;</span><span class="n">b_needsfree</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">b_ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You might already noticed that the buffer is 0 initialized, and gets freed when it gets finalized. The finalization happens in <code class="highlighter-rouge">PyCData_dealloc</code> which does a free if needed.</p>

<h2 id="next-in-the-series">Next in the series</h2>

<p>Originally I was planning to write 3 part series. But then I got interested in <a href="www.pypy.org">PyPy</a> and decided to research into PyPy a bit more. In particular I suspect CFFI might have much better perf (at least in theory) than ctypes with a proper JIT implementation since the arguments “marshaling” can be pretty much “inlined”, but that also requires JIT to be aware of various calling conventions, which is also a pretty daunting task as well (essentially implementing FFI in the JIT).</p>

<p>I’ll update them with links once they become available:</p>

<ul>
  <li><a href="/python-interop-ctypes">Part 1 - CTypes</a></li>
  <li><a href="/python-interop-capi">Part 2 - writing CPython extensions using Python/C API</a></li>
  <li><a href="/python-interop-inside-ctypes">Part 3 - Deep dive into ctypes implementation in CPython</a></li>
  <li>Part 4 - PyPy and CFFI</li>
</ul>
