<p>I’ve recently started learning GO and given that I’ve spent majority of my career in interop between runtimes and languages, I’m naturally curious on how you can interop between GO and other languages. It is most important to have the two functionality below:</p>
<ul>
  <li>retrieve a native function pointer</li>
  <li>call the native function pointer with arguments and receive values back</li>
</ul>

<p>I understand that you can use cgo to call into C functions, but with the above building blocks at hand, you can practically build anything, such as calling into COM functions, interop with arbitary languages, as long as they export their functionality via function pointers or library exports. Either way, after some research, I stumbled upon the syscall package. It is providing exactly what I need - supporting things like LoadLibrary/getProcAddress, and providing function to call a native function pointer.</p>

<p>The following code does something very straight-forward - load kernel32.dll (which should already be mapped into the process, for every Windows process), retrieve GetModuleFileNameW from the DLL, and call it with supplied arguments.</p>

<p>One thing worth pointing out is how to correctly supply a native buffer to GetModuleFileNameW as a LPTSTR. It is fairly straight-forward to create a uint16 slice with the right size MAX_PATH, but for some reason you need to explicitly use Unsafe.Pointer(&amp;slice[0]) to retrieve the address of the first element explicitly. If you simply pass &amp;slice, it’ll corrupt the reference and cause a panic later.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="x">
</span><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="p">(</span><span class="x">
	</span><span class="s">"fmt"</span><span class="x">
	</span><span class="s">"log"</span><span class="x">
	</span><span class="s">"syscall"</span><span class="x">
	</span><span class="s">"unsafe"</span><span class="x">
</span><span class="p">)</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">handle</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">syscall</span><span class="o">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="s">"kernel32.dll"</span><span class="p">)</span><span class="x">
	</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="x">
		</span><span class="k">return</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="n">proc</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">syscall</span><span class="o">.</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="x"> </span><span class="s">"GetModuleFileNameW"</span><span class="p">)</span><span class="x">
	</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="n">maxLen</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">255</span><span class="x">
	</span><span class="n">fileName</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">uint16</span><span class="p">,</span><span class="x"> </span><span class="n">maxLen</span><span class="p">)</span><span class="x">

	</span><span class="c">// The trick here is to use &amp;fileName[0] to get the address of the first element</span><span class="x">
	</span><span class="c">// &amp;fileName would corrupt the variable</span><span class="x">
	</span><span class="n">syscall</span><span class="o">.</span><span class="n">Syscall</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="m">3</span><span class="p">),</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">),</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fileName</span><span class="p">[</span><span class="m">0</span><span class="p">])),</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fileName</span><span class="p">)))</span><span class="x">

	</span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"GetModuleFileNameW returns </span><span class="se">\"</span><span class="s">%v</span><span class="se">\"</span><span class="s">."</span><span class="p">,</span><span class="x"> </span><span class="n">syscall</span><span class="o">.</span><span class="n">UTF16ToString</span><span class="p">(</span><span class="n">fileName</span><span class="p">))</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>A cursory look seems to suggest that all these are implemented using cgocall (used by cgo internally) which essentially send the args over to an assembly helper. My next post is probably going to be comparing this with p/invokes and see what is the performance difference. Thanks for reading!</p>

