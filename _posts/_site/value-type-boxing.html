<p>I recently had some really interesting discussion with a .NET typesystem expert in the team, and during the conversation he had pointed out an interesting aspect of .NET value type boxing when using constraints. Intrigued by that discussion, I decided to take a further look.</p>

<h2 id="the-basics">The basics</h2>

<p>Before we dig into the details, let’s review some basics and see how boxing can come into play when calling value type methods.</p>

<p>Suppose we have the following code:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">interface</span> <span class="nc">IAdd</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">Add</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">Foo</span> <span class="p">:</span> <span class="n">IAdd</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="k">value</span><span class="p">;</span>

    <span class="k">void</span> <span class="n">IAdd</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">value</span> <span class="p">+=</span> <span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">AddValue</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">value</span> <span class="p">+=</span> <span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Print</span><span class="p">(</span><span class="kt">string</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">msg</span> <span class="p">+</span> <span class="s">":"</span> <span class="p">+</span> <span class="k">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Nothing fancy here. Foo is a struct that has a <code class="highlighter-rouge">value</code> integer field. It privately implements an interface method that attempts to mutates it’s value, as well as a regular method that does the same thing.</p>

<p>Now if we have the following code:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">Foo</span> <span class="n">f</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Foo</span><span class="p">();</span>
        <span class="n">f</span><span class="p">.</span><span class="k">value</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>
        
        <span class="n">f</span><span class="p">.</span><span class="nf">AddValue</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
        <span class="n">f</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">"After calling AddValue"</span><span class="p">);</span>

        <span class="p">((</span><span class="n">IAdd</span><span class="p">)</span> <span class="n">f</span><span class="p">).</span><span class="nf">Add</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
        <span class="n">f</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">"After calling IAdd.Add"</span><span class="p">);</span>
</code></pre></div></div>

<p>What is the correct value after AddValue call and the Add call?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Initial Value:10
After calling AddValue:20
After calling IAdd.Add:20
</code></pre></div></div>

<p>If you are familiar with the language, this is perhaps not surprising to you at all.</p>

<p>But let’s dig a bit deeper and see how JIT does it:</p>

<p>Let’s take a look at the AddValue call first.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lea     rcx,[rbp-18h]
mov     edx,0Ah
call    00007ff8`cfa700e0
</code></pre></div></div>

<p>Note that I’m showing x64 assembly code, which is much easier to understand. The first 4 arguments are always passed in register <code class="highlighter-rouge">rcx</code>, <code class="highlighter-rouge">edx</code>, <code class="highlighter-rouge">r8</code>, <code class="highlighter-rouge">r9</code> (rest is passed through stack), and return value is returned in <code class="highlighter-rouge">rax</code>. All these are 64-bit wide registers. In the code above, JIT is passing the ‘this’ pointer in rcx (pointing to portion of the stack starting at <code class="highlighter-rouge">rbp-18h</code>, and the integer 10 (0x0a) in <code class="highlighter-rouge">rdx/edx</code> (<code class="highlighter-rouge">edx</code> is simply the lower 32-bit portion of <code class="highlighter-rouge">rdx</code>).</p>

<p>Now if you look at the actual code Foo.AddValue:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00:000&gt; !u 00007ff8`cfa70670
Normal JIT generated code
Foo.AddValue(Int32)
Begin 00007ff8cfa70670, size 36
&gt;&gt;&gt; 00007ff8`cfa70670 55              push    rbp
sub     rsp,20h
lea     rbp,[rsp+20h]
mov     qword ptr [rbp+10h],rcx        ; this pointer getting saved
mov     dword ptr [rbp+18h],edx        ; this is integer 10
mov rax,7FF8CF964560h
cmp     dword ptr [rax],0
je      00007ff8`cfa70695
call    clr!JIT_DbgIsJustMyCode (00007ff9`2f534eb0)
nop
mov     eax,dword ptr [rbp+18h]        ; integer 10
mov     rdx,qword ptr [rbp+10h]        ; this pointer getting restored
add     dword ptr [rdx],eax            ; assigning first 4-byte at 'this' with 10
nop
lea     rsp,[rbp]
pop     rbp
ret
</code></pre></div></div>

<p>Feel free to ignore some of the debugging gibberish (<code class="highlighter-rouge">clr!JIT_DbgIsJustMyCode</code>). If you follow my comments in the assembly (starting with <code class="highlighter-rouge">;</code>), you can see <code class="highlighter-rouge">10</code> is being added to the first 4-byte memory location at ‘this’, which is exactly what <code class="highlighter-rouge">value += val</code> is supposed to do.</p>

<p>And you get the following:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Initial Value:10
After calling AddValue:20
</code></pre></div></div>

<h2 id="interface-call-into-the-value-type-instance-method">Interface call into the value type instance method</h2>

<p>Now, let’s take a look at the interface call - the interface call gets a bit more complicated:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov rcx,7FF8CF965BB0h                        ; first arg to allocation routine - the Foo struct type
call    clr!JIT_TrialAllocSFastMP_InlineGetThread ; this is the allocation
mov     qword ptr [rbp-20h],rax                   ; rax is the created boxed 'Foo' struct
mov     ecx,dword ptr [rbp-18h]                   ; foo.value
mov     rdx,qword ptr [rbp-20h]                   ; boxed foo
mov     dword ptr [rdx+8],ecx                     ; copy foo to boxed foo
mov     rcx,qword ptr [rbp-20h]
mov     qword ptr [rbp-28h],rcx
mov     rcx,qword ptr [rbp-28h]                   ; rcx points to the new boxed 'Foo' struct on the heap
mov     edx,0Ah                                   ; = 10
mov r11,7FF8CF970020h                        ; r11 is the target 
cmp     dword ptr [rcx],ecx                       ; this does the 'null' check and triggers a NullRefernceException if needed
call    qword ptr [r11]                           ; interface dispatch code
</code></pre></div></div>

<p>Again, I’ve put comments on the right side of the assembly code. It basically creates a boxed Foo, copy the value to the newly created boxed Foo, . Note the <code class="highlighter-rouge">8</code> offset is for the <code class="highlighter-rouge">MethodTable</code> pointer in the beginning of the object - only objects and boxed value type (which is an object, naturally) has those. A regular value type doesn’t.</p>

<p>Ignor all the interface dispatch code for now (it’s not relevant to our discussion), eventually you’ll arrive at some interesting instructions below:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>add     rcx,8                          ; skip the MethodTable pointer and to the first field
mov rax,7FF8CF965B78h             
mov     rax,qword ptr [rax]            ; retrieve Foo.Add method
jmp     rax
</code></pre></div></div>

<p>This code doesn’t really do much. But actually gives us a lot of insight on how the system works together. Looking back at the old code we’ve shown earlier for <code class="highlighter-rouge">AddValue</code> method, it basically expects this pointer to point to the first field. However, all objects, in order to support type operations (such as reflection, casting, etc) has their first pointer-size field as the type pointer, which is called MethodTable in CLR jargon. Therefore, CLR needs to generate <em>unboxing stub</em> that unbox the boxed value and calls the underlying JITted method that expects to work with an unboxed <code class="highlighter-rouge">this</code> pointer. Note that the unboxing doesn’t involve a copy, it simply adds an offset to it. This effectively means that the += operation would take effect on the boxed copy. However, since the boxed Foo is only known to the compiler, the newly updated value is forever lost. And that’s why you would see:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>After calling IAdd.Add:20
</code></pre></div></div>

<h2 id="a-case-with-generics">A case with generics</h2>

<p>Now let’s add some generics in the mix:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">static</span> <span class="k">void</span> <span class="n">Add_WithoutConstraints</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">ref</span> <span class="n">T</span> <span class="n">foo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">((</span><span class="n">IAdd</span><span class="p">)</span><span class="n">foo</span><span class="p">).</span><span class="nf">Add</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="n">Add_WithoutConstraints</span><span class="p">&lt;</span><span class="n">Foo</span><span class="p">&gt;(</span><span class="k">ref</span> <span class="n">f</span><span class="p">,</span> <span class="m">10</span><span class="p">);</span>
    <span class="n">f</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">"After Add_WithoutConstrats"</span><span class="p">);</span>
</code></pre></div></div>

<p>Even though it is a fancy generic method, the call itself and the underlying code is nothing surprising. As you might already expect, even though the caller passes Foo by reference, <code class="highlighter-rouge">Add_WithoutConstraint</code> makes a copy of it before it calls into IAdd, and the modification is again, forever lost.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>After Add_WithoutConstrats:20
</code></pre></div></div>

<h2 id="adding-constraints">Adding constraints</h2>

<p>Now the interesting case that I’d like to talk about earlier in the article (thanks for staying with me so far!). Let’s create a generic method with a generic constraint where the T is an IAdd interface:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">static</span> <span class="k">void</span> <span class="n">Add_WithConstraints</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">ref</span> <span class="n">T</span> <span class="n">foo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">IAdd</span>
    <span class="p">{</span>
        <span class="n">foo</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">Add_WithConstraints</span><span class="p">&lt;</span><span class="n">Foo</span><span class="p">&gt;(</span><span class="k">ref</span> <span class="n">f</span><span class="p">,</span> <span class="m">10</span><span class="p">);</span>
    <span class="n">f</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">"After Add_WithConstraints"</span><span class="p">);</span>
</code></pre></div></div>

<p>Perhaps it isn’t entirely obvious to everyone - foo.Add(val) is an interface call using callvirt instruction: <code class="highlighter-rouge">callvirt   instance void IAdd::Add(int32)</code>, because that’s the only way compiler knows how to make the call.</p>

<p>The interesting part is, when we call Add_WithConstraints, the call happens exactly in the same manner, except the code we are calling into looks drastically different:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0:000&gt; !u 00007ff8`cfa707d0
Normal JIT generated code
Program.Add_WithConstraints[[Foo, value]](Foo ByRef, Int32)
Begin 00007ff8cfa707d0, size 3a
&gt;&gt;&gt; push    rbp
sub     rsp,20h
lea     rbp,[rsp+20h]
mov     qword ptr [rbp+10h],rcx           ; this pointer
mov     dword ptr [rbp+18h],edx           ; val
mov rax,7FF8CF964560h                     ; debugger gibberish 
                                          ; but you probably guessed it's for Just My Code
cmp     dword ptr [rax],0
je      00007ff8`cfa707f5
call    clr!JIT_DbgIsJustMyCode (00007ff9`2f534eb0)
nop
mov     rcx,qword ptr [rbp+10h]                  ; this pointer
mov     edx,dword ptr [rbp+18h]                  ; val
call    00007ff8`cfa706c0 (Foo.IAdd.Add(Int32)   ; calls the method without boxing!
nop
nop
lea     rsp,[rbp]
pop     rbp
ret
</code></pre></div></div>

<p>As you can see, the code is surprisingly simple. No boxing, no interface cast, and a direct call to <code class="highlighter-rouge">Foo.IAdd.Add</code> method. No value is lost. And you can observe the side effect:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>After Add_WithConstraints:30
</code></pre></div></div>

<p>The reason is compiler now has enough information to figure out the code is for Foo and the interface call will land exactly on <code class="highlighter-rouge">Foo.IAdd.Add</code>, so it skips the formality and calls the function directly. This is both a performance optimization but also comes with observable side-effect.</p>

<h2 id="conclusion">Conclusion</h2>

<p>When you are working with interface on value types, be aware of the potential performance cost of boxing and correctness problem of not observing changes in the callee. If you’d like to avoid that, you can use generic constraints to constraint the interface call so that compiler can optimize out the boxing and interface call altogether and go straight to the right function.</p>

<p>You can find the full code in this <a href="https://gist.github.com/yizhang82/f449cfef5cc92ed089bd759cfd2debcd">gist</a>.</p>
