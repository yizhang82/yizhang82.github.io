<p>In my previous blog I talked about how to call to C functions directly using syscall module, without using Cgo. We can expand this idea a bit further - to call COM objects in Go. As a simple example, letâ€™s see if we can call IMalloc interface implemented in Windows.</p>

<p>To give a bit background, IMalloc is a COM interface that provides malloc/free equivalent functionality, and more importantly, through the process-wide allocator obtained through <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms693395(v=vs.85).aspx">CoGetMalloc</a>, allow caller/callee to exchange memory ownership, as long as they agree on using the same memory allocator. Simply put, caller from module A could pass a buffer allocated in A, and pass to module B, which can free it, both using process-wide IMalloc allocator. C++ developers are probably familiar with the scenario - if you send a object malloc-ed from one module, and pass to another module which does the free, there is no guaratee that the free would succeed since the two modules might have different allocator used (if they use different CRT library, or both compiled the CRT in statically).</p>

<p>The interface is defined as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
interface IMalloc : public IUnknown
{
public:
    virtual void *STDMETHODCALLTYPE Alloc( 
        /* [in] */ SIZE_T cb) = 0;
    
    virtual void *STDMETHODCALLTYPE Realloc( 
        /* [in] */ void *pv,
        /* [in] */ SIZE_T cb) = 0;
    
    virtual void STDMETHODCALLTYPE Free( 
        /* [in] */ void *pv) = 0;
    
    virtual SIZE_T STDMETHODCALLTYPE GetSize( 
        /* [in] */ void *pv) = 0;
    
    virtual int STDMETHODCALLTYPE DidAlloc( 
        void *pv) = 0;
    
    virtual void STDMETHODCALLTYPE HeapMinimize( void) = 0;
    
};

</code></pre></div></div>

<p>The functions here are pretty straight-forward. If you are curious, you can refer to the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms678425(v=vs.85).aspx">documentation</a></p>

<p>Calling CoGetMalloc should be pretty straight-forward using syscall module as discussed in the previous post. Calling the underlying COM object requires slightly more work. COM is an ABI protocol that supports simple v-table based call dispatch, lifetime management, and threading (probably the most confusing part). To call a COM interface, you only need to call through the v-table, which is a series of function pointer pointing to the underlying code. To define v-table in go, it would look something like this:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">MallocVtbl</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">queryInterface</span><span class="x"> </span><span class="kt">uintptr</span><span class="x"> 
    </span><span class="n">addref</span><span class="x"> </span><span class="kt">uintptr</span><span class="x">
    </span><span class="n">release</span><span class="x"> </span><span class="kt">uintptr</span><span class="x">
    </span><span class="n">alloc</span><span class="x"> </span><span class="kt">uintptr</span><span class="x">
    </span><span class="n">realloc</span><span class="x"> </span><span class="kt">uintptr</span><span class="x">
    </span><span class="n">free</span><span class="x"> </span><span class="kt">uintptr</span><span class="x">
    </span><span class="n">getSize</span><span class="x"> </span><span class="kt">uintptr</span><span class="x">
    </span><span class="n">didAlloc</span><span class="x"> </span><span class="kt">uintptr</span><span class="x">
    </span><span class="n">heapMinimize</span><span class="x"> </span><span class="kt">uintptr</span><span class="x">
</span><span class="p">}</span><span class="x"> 
</span></code></pre></div></div>

<p>Note that the order is very important - it needs to match exactly with the interface itself, and the first 3 is always coming from IUnknown methods.</p>

<p>The v-table pointer can be obtained from the first pointer in the object.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span><span class="x"> </span><span class="n">malloc</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">;</span><span class="x">  </span><span class="c">// This is the IMalloc*</span><span class="x">

</span><span class="n">mallocVtblPtr</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">malloc</span><span class="p">))</span><span class="x"> </span><span class="c">// Get the vtable pointer</span><span class="x">

</span><span class="n">mallocVtbl</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="p">(</span><span class="o">*</span><span class="n">MallocVtbl</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">mallocVtblPtr</span><span class="p">))</span><span class="x">  </span><span class="c">// Convert to the right MallocVtbl*</span><span class="x">
</span></code></pre></div></div>

<p>Once we have the vtable, getting the underlying function pointer is a simple matter of using the right fields, and then we can call it using syscall like before:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">memPtr</span><span class="p">,</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">syscall</span><span class="o">.</span><span class="n">Syscall</span><span class="p">(</span><span class="n">mallocVtbl</span><span class="o">.</span><span class="n">alloc</span><span class="p">,</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="m">2</span><span class="p">),</span><span class="x"> </span><span class="n">malloc</span><span class="p">,</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="n">memSize</span><span class="p">),</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">))</span><span class="x">  
</span></code></pre></div></div>

<p>You can find the full code below:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="x">
</span><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="p">(</span><span class="x">
    </span><span class="s">"fmt"</span><span class="x">
    </span><span class="s">"log"</span><span class="x">
    </span><span class="s">"syscall"</span><span class="x">
    </span><span class="s">"unsafe"</span><span class="x">
</span><span class="p">)</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">MallocVtbl</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">queryInterface</span><span class="x"> </span><span class="kt">uintptr</span><span class="x"> 
    </span><span class="n">addref</span><span class="x"> </span><span class="kt">uintptr</span><span class="x">
    </span><span class="n">release</span><span class="x"> </span><span class="kt">uintptr</span><span class="x">
    </span><span class="n">alloc</span><span class="x"> </span><span class="kt">uintptr</span><span class="x">
    </span><span class="n">realloc</span><span class="x"> </span><span class="kt">uintptr</span><span class="x">
    </span><span class="n">free</span><span class="x"> </span><span class="kt">uintptr</span><span class="x">
    </span><span class="n">getSize</span><span class="x"> </span><span class="kt">uintptr</span><span class="x">
    </span><span class="n">didAlloc</span><span class="x"> </span><span class="kt">uintptr</span><span class="x">
    </span><span class="n">heapMinimize</span><span class="x"> </span><span class="kt">uintptr</span><span class="x">
</span><span class="p">}</span><span class="x">   

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Loading ole32.dll...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="x">

    </span><span class="n">handle</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">syscall</span><span class="o">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="s">"ole32.dll"</span><span class="p">)</span><span class="x">
    </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="x">
        </span><span class="k">return</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="n">proc</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">syscall</span><span class="o">.</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="x"> </span><span class="s">"CoGetMalloc"</span><span class="p">)</span><span class="x">
    </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Calling CoGetMalloc</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">malloc</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">;</span><span class="x">
    </span><span class="n">ret</span><span class="p">,</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">syscall</span><span class="o">.</span><span class="n">Syscall</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="m">2</span><span class="p">),</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="m">1</span><span class="p">),</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">malloc</span><span class="p">)),</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">))</span><span class="x">
    </span><span class="k">if</span><span class="x"> </span><span class="n">ret</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="m">0</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"CoGetMalloc returned %x</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">malloc</span><span class="p">)</span><span class="x"> 

    </span><span class="n">mallocVtblPtr</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">malloc</span><span class="p">))</span><span class="x">
    </span><span class="n">mallocVtbl</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="p">(</span><span class="o">*</span><span class="n">MallocVtbl</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">mallocVtblPtr</span><span class="p">))</span><span class="x">

    </span><span class="k">const</span><span class="x"> </span><span class="n">memSize</span><span class="x"> </span><span class="kt">int</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="m">100</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Calling IMalloc::Alloc(%v)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">memSize</span><span class="p">)</span><span class="x">
    </span><span class="n">memPtr</span><span class="p">,</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">syscall</span><span class="o">.</span><span class="n">Syscall</span><span class="p">(</span><span class="n">mallocVtbl</span><span class="o">.</span><span class="n">alloc</span><span class="p">,</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="m">2</span><span class="p">),</span><span class="x"> </span><span class="n">malloc</span><span class="p">,</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="n">memSize</span><span class="p">),</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">))</span><span class="x">
    
    </span><span class="k">if</span><span class="x"> </span><span class="n">memPtr</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="m">0</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="x">
       
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"IMalloc::Alloc returned %x</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">memPtr</span><span class="p">)</span><span class="x"> 
 
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Calling IMalloc::GetSize with %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">memPtr</span><span class="p">)</span><span class="x">

    </span><span class="n">returnedSize</span><span class="p">,</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">syscall</span><span class="o">.</span><span class="n">Syscall</span><span class="p">(</span><span class="n">mallocVtbl</span><span class="o">.</span><span class="n">getSize</span><span class="p">,</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="m">2</span><span class="p">),</span><span class="x"> </span><span class="n">malloc</span><span class="p">,</span><span class="x"> </span><span class="n">memPtr</span><span class="p">,</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">))</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"IMalloc::GetSize returned %v</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">returnedSize</span><span class="p">)</span><span class="x">

    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Calling IMalloc::Free with %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">memPtr</span><span class="p">);</span><span class="x">
    </span><span class="n">syscall</span><span class="o">.</span><span class="n">Syscall</span><span class="p">(</span><span class="n">mallocVtbl</span><span class="o">.</span><span class="n">free</span><span class="p">,</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="m">2</span><span class="p">),</span><span class="x"> </span><span class="n">malloc</span><span class="p">,</span><span class="x"> </span><span class="n">memPtr</span><span class="p">,</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">))</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"IMalloc::Free succeeded</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span><span class="x">

    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Calling IMalloc::DidAlloc with %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">memPtr</span><span class="p">)</span><span class="x">
    </span><span class="n">ret</span><span class="p">,</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">syscall</span><span class="o">.</span><span class="n">Syscall</span><span class="p">(</span><span class="n">mallocVtbl</span><span class="o">.</span><span class="n">didAlloc</span><span class="p">,</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="m">2</span><span class="p">),</span><span class="x"> </span><span class="n">malloc</span><span class="p">,</span><span class="x"> </span><span class="n">memPtr</span><span class="p">,</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">))</span><span class="x">
    </span><span class="n">didAlloc</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="kt">bool</span><span class="p">(</span><span class="n">ret</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="m">0</span><span class="p">)</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"IMalloc::DidAlloc returned %v</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">didAlloc</span><span class="p">);</span><span class="x">

    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Calling IMalloc::Release</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="x">
    </span><span class="n">ret</span><span class="p">,</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">syscall</span><span class="o">.</span><span class="n">Syscall</span><span class="p">(</span><span class="n">mallocVtbl</span><span class="o">.</span><span class="n">release</span><span class="p">,</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="m">1</span><span class="p">),</span><span class="x"> </span><span class="n">malloc</span><span class="p">,</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">),</span><span class="x"> </span><span class="kt">uintptr</span><span class="p">(</span><span class="m">0</span><span class="p">))</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"IMalloc::Release returned %v</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">ret</span><span class="p">);</span><span class="x">
</span><span class="p">}</span><span class="x">

</span></code></pre></div></div>

